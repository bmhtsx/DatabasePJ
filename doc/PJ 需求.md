# PJ 需求

### 原始需求

- 代码静态扫描工具能检测出代码中的静态缺陷
- 开发人员想知道各个静态缺陷是什么时候由谁引入，从而判断相应的修复方式
- 代码修改的历史对目前的判断可能是有影响的
- 需要在数据库中存储多个软件代码库中各个版本（按commit为单位）的静态缺陷的信息
- Commit本来是一组代码修改的提交操作，对应了提交前和提交后两个版本
- 但习惯上，我们用commit指代提交后的那个版本
- 对任意一个版本的任意一个静态缺陷，能找到它前后版本中对应的静态缺陷（对应关系的准确性另案分析）

### 数据分析需求

- 最新版本中，静态缺陷数量的分类统计，以及详细列表
  - 按类型统计
  - 详情按存续时长排序
  - 按类型统计存续时长的平均值和中位值

- 指定版本的代码快照中，静态缺陷引入、消除情况的分类统计，以及详细列表
- 指定一段时间内，静态缺陷的引入、消除情况的分类统计，以及详细列表
- 指定开发人员在一段时间内，静态缺陷引入（已解决和未解决）、解决（他人引入和自己引入）情况
- 数据分析统计
  - 在指定时间段内引入静态缺陷的数量，以及解决情况（包括解决率以及解决所需的时间，按总量以及分各
    个缺陷大类和具体类型统计）
  - 现存静态缺陷中，已经存续超过指定时长（比如1年）的分类数量统计
  - 从开发人员的角度来看，解决自己引入缺陷、解决他人引入缺陷、自己引入且未解决缺陷、自己引入且被他人解决缺陷的分类数量统计，存活周期统计
  - 统计数据需要有相应的详细信息

- 数据的表示
  - 每个版本的静态缺陷
  - 前后版本静态缺陷的追踪关系
  - 考虑多个代码仓
  - 一个仓内考虑单个目标分支，但会有多分支的合并

- 具体考虑
  - 一个静态缺陷可以表现在代码文件中的多处
    - flow
  - 同一个静态缺陷会在不同版本(commit)上出现
    - 假设已经有一个简单的版本间匹配的算法：通过上下文
      能分辨出某个静态缺陷对应前一个版本的哪个静态缺陷
  - 不同仓、不同的分支上可以有相同的commit
  - 静态缺陷状态变化的历史

- 其他思考
  - 与merge相关
    - 考虑合并节点上，静态缺陷相对于不同的parent
      commit有不同的变化状态
  - 与跨代码库、跨分支相关
    - 不同代码库中commit hash相同时，如何高效处理和
      分析？
    - 扫描时按照给定的branch进行扫描，若不同branch中
      commit hash相同时，如何高效处理和分析？

### 性能与可靠性需求

- 性能
  - 支持代码仓的代码规模百万行级，提交数量500+
    - 一般企业级项目的更新频度和强度
    - 支持静态缺陷数量（跨版本总量）在百万甚至千万级别以上
  - 冷启动时间在合理的较长时间内（比如1-2天）
  - 单库日常扫描（代码增量扫描）单版本数据更新在分钟级
- 可靠性
  - 考虑到建立版本间映射算法准确性，应能按需更新算法
    并刷新数据
  - 因为调用静态扫描工具时，扫描速度甚至正确性都不可
    控，因此为了便于数据修复，需要原始数据入库与扫描
    需单独运行